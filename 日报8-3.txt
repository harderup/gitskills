主题：日报
日期：2019年8月3日	星期6
内容：
1.今天学习的内容：
肖依云学姐分享了秒杀应该怎样应对高并发
（1）网关
（2）漏桶
（3）令牌桶
（4）降级处理
	
		
2.没有解决的问题：
	Guava源码，i++线程安全等。
3.明天的学习计划：
	学姐分享mysql
	
算法：
1.仅使用递归将一个栈进行逆制

public class PreStatck {

    //  取出栈底的元素
    private static int getLast(LinkedList<Integer> s){
        int popData=s.pop();
        if (s.isEmpty()){
            return popData;
        }
        int last=getLast(s);

        //  返回栈底元素，剩下元素按原顺序不变
        s.push(popData);
        return last;
    }


    public static void reserve(LinkedList<Integer> s){
        if (s.isEmpty()){
            return;
        }
        int last=getLast(s);
        reserve(s);//   递归前，栈底元素已经已被溢出，存放在last变量中

        s.push(last);
    }

    public static void main(String[] args) {
        LinkedList<Integer> s=new LinkedList<>();
        s.add(1);
        s.add(2);
        s.add(3);

        for (Integer elem :s){
            System.out.println(elem);
        }
    }
}

2.实现猫狗队列（add,pollAll,pollCat,pollDog,isEmpty,dogIsEmpty,catIsEmpty)

public class CatDogQueue {

    static class Pet{
        private String type;
        public Pet(){}
        public Pet(String type){this.type=type;}
        public String getType() {
            return type;
        }
        public void setType(String type) {
            this.type = type;
        }
    }
    static class Cat extends Pet{
        public Cat(){super("Cat");}
    }
    static class Dog extends Pet{
        public Dog(){super("Dog");}
    }

    //  因为不能让破坏原有的Pet,Cat,Dog类，所以对其进行包装（主要是添加count属性，决定Cat与Dog的添加次序）
    static class BothPet{
        private Pet pet;
        private int count;
        public BothPet(){}
        public BothPet(Pet pet,int count){
            this.pet=pet;
            this.count=count;
        }
        public Pet getPet() {
            return pet;
        }
        public void setPet(Pet pet) {
            this.pet = pet;
        }
        public int getCount() {
            return count;
        }
        public void setCount(int count) {
            this.count = count;
        }
    }

    static class CatAndDogQueue{
        private LinkedList<BothPet> catQ;
        private LinkedList<BothPet> dogQ;
        private int count;

        public CatAndDogQueue(){
            catQ=new LinkedList<>();
            dogQ=new LinkedList<>();
        }

        public void add(Pet pet){
            if (pet.getType().equals("Cat")){
                catQ.add(new BothPet(pet,count++));
            }else if (pet.getType().equals("Dog")){
                dogQ.add(new BothPet(pet,count++));
            }else{
                throw new RuntimeException("Unexpected case!");
            }
        }

        public Pet pollAll(){
            if (!catQ.isEmpty()&&!dogQ.isEmpty()){
                if (catQ.peek().getCount()<dogQ.peek().getCount()){
                    return catQ.poll().getPet();
                }else{
                    return dogQ.poll().getPet();
                }
            }else if (!catQ.isEmpty()){
                return catQ.poll().getPet();
            }else if (!dogQ.isEmpty()){
                return dogQ.poll().getPet();
            }else{
                throw new RuntimeException("queue is empty!");
            }
        }

        public Pet pollCat(){
            if (!catQ.isEmpty()){
                return catQ.poll().getPet();
            }else{
                throw new RuntimeException("queue is empty!");
            }
        }

        public Pet pollDog(){
            if (!dogQ.isEmpty()){
                return dogQ.poll().getPet();
            }else{
                throw new RuntimeException("queue is empty!");
            }
        }
    }

    public static void main(String[] args) {
        CatAndDogQueue cd=new CatAndDogQueue();
        cd.add(new Cat());
        cd.add(new Cat());
        cd.add(new Dog());
        cd.add(new Cat());
        cd.add(new Dog());

        System.out.println(cd.pollAll().getType());
        System.out.println(cd.pollDog().getType());
        System.out.println(cd.pollCat().getType());
        System.out.println(cd.pollAll().getType());
    }
}