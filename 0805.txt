Java虚拟的调优：
分为早期编译时优化和晚期的运行时优化
编译优化：
解析：词法分析语法分析
生成符号表
语义分析和字节码生成
语法糖的处理：自动拆装箱，泛型的擦除、条件编译
运行时优化：
分为解析过程和编译过程
解析过程触发即时编译转换到编译过程
有两个即时编译器，Client Compiler和Server Compiler简称c1编译器和c2编译器
被多次调用的方法和被多次执行的循环体会触发即时编译。触发的条件是调用次数达到一定的数量就发触发，这个数量肯定是有一个标准，那么标准是什么？通过两种方法来检测是否可以触发即时编译
方法一：基于采样的热点探测
方法二：基于计数器的热点探测
采样的热点探测是虚拟机会周期性的检查各个栈顶，发现某个方法经常出现在栈顶，那么就认为是热点方法；
计数器的热点探测有两类计数器：方法调用计数器和回边计数器，两个计数器都有一定的阈值，当计数器超过这个阈值，就会触发JIT编译。
当调用一个方法时，先会检查它是否已经被JIT编译过，如果已经被编译，则使用编译后的本地代码执行，如果没有，调用此方法将该方法计数器加1，然后判断方法计数器和回边计数器的和是否大于方法计数器的阈值，超过了会触发JIT编译。

快速排序
public void quickSort(int []arr,int start,int end){
	if(arr==null||arr.length==0){return; }
	int pivot = arr[start];
	int i = start,int j = end;
	while(i<j){
		while(i<j&&arr[j]>=pivot){j--;}
		if(i<j) arr[i++] = arr[j];
		while(i<j&&arr[i]<=pivot){i++;}
		if(i<j) arr[j--] = arr[i];
	}
	arr[start] = pivot;
	quickSort(arr.start,i-1);
	quickSort(arr,i+1,end);
}



















