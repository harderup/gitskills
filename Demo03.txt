7/15
1	日报
1.1	工作内容
1.1.1	内容
和前端讨论项目需求
建立GIT项目 创建属于自己的分支
完成情况：项目需求基本确定，git项目未建立
1.1.1.1	问题&自己思考
有些功能现阶段的能力还不能实现，比如说支付功能，和支付宝，微信的接口，都不知道怎么弄。
我想法是：对于现阶段实现起来有困难的功能，留下接口，等到时候学习相应知识再完善相应细节
2	计划
2.1	工作内容
2.1.1	内容
确定项目需求
完成刘老师留下的代码
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
解析：运用Treemap存储 数组中出现的次数及出现次数，之后遍历map寻找大于长度一半的value；
import java.util.TreeMap;

public class Solution {
    
    public int MoreThanHalfNum_Solution(int [] array) {
    		TreeMap<Integer,Integer>  data=new TreeMap<Integer,Integer>();
		for(int i=0;i<array.length;i++) {
			if(data.containsKey(array[i])) {
				data.put(array[i], data.get(array[i])+1);
			}else {
				data.put(array[i], 1);
			}
		}
	for(Integer key:data.keySet()) {
	if(2*data.get(key)>array.length){
        return key;
    }
} 
        return 0;
    }
}
输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
解析：遍历二叉树并用target-root.value当根节点无左右结点，且root.value=target时，将路径保存
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
         ArrayList<ArrayList<Integer>> arraylist = new ArrayList<ArrayList<Integer>>();
    ArrayList<Integer> list = new ArrayList<Integer>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        if(root==null)
            return arraylist;
        list.add(root.val);
        if(root.left==null&&root.right==null&&target==root.val){
            arraylist.add(new ArrayList<Integer>(list));
        }
        if(root.val<=target&&root.left!=null){
            FindPath(root.left,target-root.val);
        }
     if(root.val<=target&&root.right!=null){
            FindPath(root.right,target-root.val);
        }
        list.remove(list.size()-1);
        return arraylist;
    }
}
7/16
1	日报
1.1	工作内容
1.1.1	内容
完成刘老师留下的代码，熟悉代码的结构和流程。对代码中不熟悉的方法，查缺补漏。确立项目需求；学习面向对象，java特性及特点；多态的实现方式（重载、重写）
1.1.2	问题及思考
没有申明，类的默认访问权限为default 修饰符，主要是本包的类可以访问。
 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求；重写的方法的访问权限应该与父类中被重写方法的访问权限相同或高于它的访问权限 
方法重写的注意事项： 
构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同 
private修饰的成员方法不能被重写（私有的） 
static修饰的方法不能被重写 
final修饰的方法不能被重写 
调用原则：当子类重写了父类中的方法后，子类对象调用该方法时调用的是子类重写后的方法
2	计划
2.1	工作内容
2.1.1	内容
设计数据库 UML图
学习object类源码
学习maven！！！

			
题目描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
解析;建立辅助栈，用t标记出栈数组第一个元素。并按入栈数组依次入栈，每入一次就比较栈顶元素与所标记出栈元素二者相等时，入栈元素出栈，t后移，再比较栈顶元素与t所标记元素，若不相等再执行入栈操作

import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
      Stack<Integer> st=new Stack<Integer>();
       int t=0;
        for(int i=0;i<pushA.length;i++){
            st.push(pushA[i]);
            while(!st.empty()&&st.peek()==popA[t]){
            st.pop();
                t+=1;
            }
        }
        return st.isEmpty();
    }
}
题目表述：

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
解析：此处用到Integer 将数组两个元素依次转为integer类型 并调整先后顺序拼接字符串 ，如果原序列小 则不变，右移一位 继续执行以上操作
public String PrintMinNumber(int [] numbers) {
        for(int i=0;i<numbers.length-1;i++){
            for(int j=i+1;j<numbers.length;j++){
            int data1= Integer.valueOf(numbers[i]+""+numbers[j]);
             int data2 = Integer.valueOf(numbers[j]+""+numbers[i]);
            if(data1>data2){
                int t=numbers[i];
                numbers[i]=numbers[j];
                numbers[j]=t;
            }
            }
        }
        String str="";
        for(int i=0;i<numbers.length;i++){
           str=str+String.valueOf(numbers[i]);
            
        }
        return str;
}
