主题：日报
日期：2019年8月2日	
内容：
1.今天学习的内容：
		老师讲了springMVC
2.没有解决的问题：
	Spring还没有搞懂
3.明天的学习计划：
	老师上课讲SpringMVC
	算法题*2
	继续复习多线程
	
算法：继续剑指offer
1.求两个升序链表的公共部分：
public class TwoLinkCommonPart {
    static class Elemsn{
        int data;
        Elemsn next;
    }

    public static Elemsn createLink(int [] data){
        Elemsn h=null;
        for (int i=data.length-1;i>-1;i--){
            Elemsn p=new Elemsn();
            p.data=data[i];
            p.next=h;
            h=p;
        }
        return h;
    }
	
    public static void commonPart(Elemsn h1,Elemsn h2){
       while (h1!=null&&h2!=null){
           if (h1.data<h2.data){
               h1=h1.next;
           }else if ((h2.data<h1.data)){
               h2=h2.next;
           }else {
               System.out.print(h1.data+" ");
               h1=h1.next;
               h2=h2.next;
           }
       }
    }


    public static void main(String[] args) {
        int [] data1={1,1,1,2,3,3,4};
        int [] data2={2,2,3,3,4,5};
        Elemsn h1=createLink(data1);
        Elemsn h2=createLink(data2);

        commonPart(h1,h2);
    }
}

2.求单链表的倒数第k个结点
public class ThkNode {
    static class Elemsn{
        int data;
        Elemsn next;
    }

    public static Elemsn createLink(int [] data){
        Elemsn h=null;
        for (int i=data.length-1;i>-1;i--){
            Elemsn p=new Elemsn();
            p.data=data[i];
            p.next=h;
            h=p;
        }
        return h;
    }

    public static Elemsn thkNode(Elemsn h,int k){
        Elemsn p1=h,p2=null;
        int i=0;
        for (i=0;p1!=null&&i<k;i++){
            p1=p1.next;
        }

        if (i==k){
            for (p2=h;p1!=null;p1=p1.next,p2=p2.next);
        }

        return p2;
    }

    public static void main(String[] args) {
        int [] data={1,2,3,4,5,6,7};
        Elemsn h=createLink(data);
        Scanner sc=new Scanner(System.in);
        int k=sc.nextInt();
        System.out.println(thkNode(h,k).data);
    }
}